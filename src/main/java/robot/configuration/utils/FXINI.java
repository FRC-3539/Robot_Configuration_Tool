package robot.configuration.utils;

import javafx.beans.property.SimpleStringProperty;
import javafx.collections.ObservableList;
import robot.configuration.settings.SystemSettings;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class FXINI {
    Path filePath;
    SimpleStringProperty fileName = new SimpleStringProperty("");
    ObservableList<FXConstant> constants;
    SimpleStringProperty lastModified = new SimpleStringProperty();

    public FXINI(Path filePath) {
        this(new INI(filePath));
    }

    public FXINI(INI ini) {
        setFilePath(ini.filePath);
        constants = javafx.collections.FXCollections.observableArrayList();
        for (Constant constant : ini.constants) {
            this.constants.add(new FXConstant(this, constant));
        }
        this.lastModified.set(ini.lastModified);
    }

    public ObservableList<FXConstant> getConstants() {
        return constants;
    }

    public void renameFile(String newName) throws IOException {
        String directory = filePath.getParent().toString();
        if (directory == null) {
            directory = ".";
        }
        String newFilePath = directory + File.separator + newName + ".ini";
        File oldFile = filePath.toFile();
        File newFile = new File(newFilePath);
        if (oldFile.renameTo(newFile)) {
            setFilePath(newFile.toPath());
        } else {
            throw new IOException("Failed to rename file: " + filePath + " to " + newFilePath);
        }
    }

    public String getFileName() {
        String name = filePath.getFileName().toString();
        int dotIndex = name.lastIndexOf('.');
        return (dotIndex == -1) ? name : name.substring(0, dotIndex);
    }

    public boolean removeConstant(FXConstant constant) {
        return constants.remove(constant);
    }

    public boolean addConstant(FXConstant constant) {
        setLastModified(new Date());
        constant.setFXINI(this);
        return constants.add(constant);
    }

    public INI toINI() {
        // Convert FXConstant to Constant
        ArrayList<Constant> constantList = new ArrayList<>();
        for (FXConstant fxConstant : constants) {
            constantList.add(fxConstant.toConstant());
        }
        INI ini = new INI(this.filePath, constantList, lastModified.get());
        return ini;
    }

    public void setFilePath(Path absolutePath) {
        this.filePath = absolutePath;
        String name = filePath.getFileName().toString();
        int dotIndex = name.lastIndexOf('.');
        this.fileName.set((dotIndex == -1) ? name : name.substring(0, dotIndex));
    }

    public Path getFilePath() {
        return this.filePath;
    }

    public SimpleStringProperty fileNameProperty() {
        return fileName;
    }

    public SimpleStringProperty lastModifiedProperty() {
        return lastModified;
    }

    public void setLastModified(Date date) {
        java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("MM/dd/yy hh:mm:ss a");
        this.lastModified.set(sdf.format(date));
    }

    public Path getJavaPath() {
        String className = fileName.get().trim();
        return Path.of(SystemSettings.getSettings().getJavaFolder()).resolve(className + ".java");
    }

    public void generateJavaFile(boolean overwriteWholeFile) throws IOException {
        String className = fileName.get().trim();
        Path outputPath = getJavaPath();

        // Build list of constant declarations with JavaDoc
        List<String> generatedFields = new ArrayList<>();
        for (FXConstant constant : constants) {
            String type = constant.getType().trim();
            String name = constant.getName().trim();
            String value = constant.getValue().trim();
            String description = constant.getDescription();

            // Add quotes for String values
            if ("String".equals(type) && !(value.startsWith("\"") && value.endsWith("\""))) {
                value = "\"" + value.replace("\"", "\\\"") + "\"";
            }

            StringBuilder fieldBuilder = new StringBuilder();
            if (description != null && !description.isBlank()) {
                fieldBuilder.append("    /** ").append(description.trim()).append(" */\n"); // 4 spaces
            }
            fieldBuilder.append("    public static ").append(type).append(" ").append(name)
                    .append(" = ").append(value).append(";");
            generatedFields.add(fieldBuilder.toString());
        }

        String autoStart = "    /* =================== DO NOT MODIFY BELOW =================== */";
        String autoEnd = "    /* =================== END OF AUTOGENERATED BLOCK ============ */";

        String fileContent;

        if (overwriteWholeFile || !Files.exists(outputPath)) {
            // Generate entire file from scratch
            StringBuilder sb = new StringBuilder();

            String packageName = derivePackageName(outputPath);
            if (!packageName.isEmpty()) {
                sb.append("package ").append(packageName).append(";\n\n");
            }

            sb.append("import org.frcteam3539.BulldogLibrary.INIConfiguration.BBConstants;\n\n");

            sb.append("public class ").append(className).append(" extends BBConstants {\n\n")
                    .append("    public ").append(className).append("() {\n")
                    .append("        super(\"/home/lvuser/").append(className).append(".ini\", true);\n")
                    .append("        save();\n")
                    .append("    }\n\n");

            sb.append(autoStart).append("\n");
            for (String field : generatedFields) {
                sb.append(field).append("\n");
            }
            sb.append(autoEnd).append("\n\n");

            sb.append("}\n");

            fileContent = sb.toString();

        } else {
            // Safe: replace only the autogenerated block
            fileContent = Files.readString(outputPath);

            int startIdx = fileContent.indexOf(autoStart);
            int endIdx = fileContent.indexOf(autoEnd);

            // Throw error if the user tampered with the block
            if ((startIdx == -1 || endIdx == -1 || endIdx <= startIdx)) {
                throw new IOException(
                        "Autogenerated block markers have been modified or deleted in file: " + outputPath);
            }

            if (startIdx != -1 && endIdx != -1 && endIdx > startIdx) {
                // Replace existing block
                String before = fileContent.substring(0, startIdx + autoStart.length());
                String after = fileContent.substring(endIdx);

                StringBuilder block = new StringBuilder("\n");
                for (String field : generatedFields) {
                    block.append(field).append("\n");
                }

                fileContent = before + block + after;

            } else {
                // No existing block: append it before final closing brace
                int insertPos = fileContent.lastIndexOf("}");
                if (insertPos == -1)
                    throw new IOException("Invalid Java file: missing closing brace in file: " + outputPath
                            + ".");

                StringBuilder block = new StringBuilder("\n");
                block.append(autoStart).append("\n");
                for (String field : generatedFields) {
                    block.append(field).append("\n");
                }
                block.append(autoEnd).append("\n\n");

                fileContent = fileContent.substring(0, insertPos) + block + fileContent.substring(insertPos);
            }
        }

        Files.writeString(outputPath, fileContent);
    }

    // Helper: derive package name from path starting at "src"
    private String derivePackageName(Path javaFilePath) {
        List<String> parts = new ArrayList<>();
        boolean foundSrc = false;
        for (int i = 0; i < javaFilePath.getNameCount(); i++) {
            String part = javaFilePath.getName(i).toString();
            if (!foundSrc) {
                if (part.equals("src")) {
                    foundSrc = true;
                }
            } else {
                // Skip "main" and "java" after "src"
                if (part.equals("main") || part.equals("java")) {
                    continue;
                }
                // Stop before the filename
                if (i == javaFilePath.getNameCount() - 1)
                    break;
                parts.add(part);
            }
        }
        return String.join(".", parts);
    }

}
